
render_pass render_passes::scheduling : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	require modules::rt;

	set fb {
		sampler2D albedo;
		sampler2D emissive;
		sampler2D normal;

		sampler2D last_albedo;
		sampler2D last_emissive;
		sampler2D last_depth_buffer;

		sampler2D last_primary;
		sampler2D last_bounce0;
		sampler2D last_bounce1;
		sampler2D last_diffuse;
		sampler2D last_diffuse_it;

		vec3 random_sun_dir[256];

		vec3 random_diffuse[256];

		mat4 view_normal;
		mat4 cur_cam_to_last;
		mat4 cur_cam_inv;
		mat4 last_cam_inv;
	};

	out vec3 primary;
	out vec3 bounce0;
	out vec3 bounce1;
	out vec3 diffuse;
	out float diffuse_it;

	uint hash(uint x) {
		x += ( x << 10u );
		x ^= ( x >>  6u );
		x += ( x <<  3u );
		x ^= ( x >> 11u );
		x += ( x << 15u );
		return x;
	}

	vec3 last_pos_view(vec2 pos, vec2 size)
	{
		float depth = textureLod(fb.last_depth_buffer, pos, 0).x;
		float z = rt_depth_to_z(depth);
		vec2 uv = pos / size;
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2 *= rt_fb.cur_cam_ratio;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	void main(void)
	{
		vec2 size = vec2(textureSize(rt_fb.depth_buffer, 0));
		vec4 cur_view =  vec4(rt_current_view(), 1.0);
		vec4 last_view = fb.cur_cam_to_last * cur_view;
		vec2 last_view_pos = rt_project_point(last_view.xyz).xy;
		vec4 last_view_reproj = vec4(last_pos_view(last_view_pos, size), 1.0);
		float repr_dist = length((fb.cur_cam_inv * cur_view).xyz - (fb.last_cam_inv * last_view_reproj).xyz);

		const float repr_dist_tres = 0.5;
		bool repr_success = (last_view_pos.x >= 0 && last_view_pos.y >= 0 && last_view_pos.x <= (size.x - 1) && last_view_pos.y <= (size.y - 1) && (repr_dist < repr_dist_tres))
		|| texture(rt_fb.depth_buffer, gl_FragCoord.xy).x >= 0.9999999;

		(out)primary = vec3(0.0);
		(out)bounce0 = vec3(0.0);
		(out)bounce1 = vec3(0.0);
		(out)diffuse = vec3(repr_success ? 0.5 : 0.1);
		(out)diffuse_it = 0.0;
	}
}