
render_pass render_passes::reflect : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set fb {
		//usampler2D it_count;
		//uint it_bias;

		sampler2D normal;
		sampler2D diffuse;
		sampler2D last_reflect;

		mat4 cur_cam_to_last;

		vec3 random_diffuse[256];
	};

	require modules::rt;

	out vec3 reflection;

	float fresnel(float r0, float cos_angle)
	{
		return r0 + (1.0 - r0) * pow(1 - cos_angle, 5);
	}

	uint hash(uint x) {
		x += ( x << 10u );
		x ^= ( x >>  6u );
		x += ( x <<  3u );
		x ^= ( x >> 11u );
		x += ( x << 15u );
		return x;
	}

	void main(void)
	{
		const float unorm = 1.0 / 255.0;
		vec3 reflection = vec3(100.0 * unorm, 145.0 * unorm, 223.0 * unorm) * 1.5;
		vec3 view = rt_pos_view(gl_FragCoord.xy);
		vec3 view_norm = normalize(view);
		vec3 normal = texture(fb.normal, gl_FragCoord.xy).xyz;
		vec2 trace_pos;
		if (rt_traceRay(view, reflect(view_norm, normal), trace_pos) && texture(rt_fb.depth_buffer, gl_FragCoord.xy).x < 1.0) {
			reflection = texture(fb.diffuse, trace_pos).xyz;
		}
		(out)reflection = reflection;
	}
}