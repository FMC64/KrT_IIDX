
render_pass render_passes::compo : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set fb {
		sampler2D diffuse;
		sampler2D reflection;
		sampler2D refl;
		sampler2D normal;
	};

	require modules::rt;

	out vec3 compo;

	float fresnel(float r0, float cos_angle)
	{
		return r0 + (1.0 - r0) * pow(1 - cos_angle, 5);
	}

	uint hash(uint x) {
		x += ( x << 10u );
		x ^= ( x >>  6u );
		x += ( x <<  3u );
		x ^= ( x >> 11u );
		x += ( x << 15u );
		return x;
	}

	void main(void)
	{
		vec3 normal = normalize(texture(fb.normal, gl_FragCoord.xy).xyz);
		vec3 refl = texture(fb.refl, gl_FragCoord.xy).xyz;
		float reflectiveness = refl.y;
		float r0 = refl.z;
		vec3 view = rt_pos_view(gl_FragCoord.xy);
		vec3 view_norm = normalize(view);
		float actual_reflectiveness = fresnel(r0, max(dot(normal, -view_norm), 0.0)) * reflectiveness;
		vec3 diffuse = texture(fb.diffuse, gl_FragCoord.xy).xyz;
		vec3 reflection = texture(fb.reflection, gl_FragCoord.xy).xyz;
		(out)compo = mix(diffuse, reflection, actual_reflectiveness);
	}
}