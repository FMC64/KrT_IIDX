
render_pass render_passes::post : lighting;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set fb {
		sampler2D color;
		sampler2D depth_buffer;
	};

	const float pi = 3.141592653589793238462643383279502884;

	float ang_to_rad(float ang)
	{
		return ang * (pi / 180.0);
	}

	const vec2 depth_buffer_uv = vec2(1600.0, 900.0) / vec2(2048.0);

	vec3 current_view(void)
	{
		vec2 size = textureSize(fb.color, 0);
		vec2 uv = gl_FragCoord.xy / size;
		float depth = texture(fb.depth_buffer, uv * depth_buffer_uv).x;
		const float near = 0.1, far = 1000.0;
		const float a = far / (far - near), b = -(far * near) / (far - near);
		const float tanHalfFovy = tan(ang_to_rad(120.0) / 2.0);
		float z = b / (depth - a);
		vec2 ndc2 = (uv - 0.5) * 2.0;
		ndc2.x *= (16.0 / 9.0) * tanHalfFovy;
		ndc2.y *= -1.0 * tanHalfFovy;
		ndc2 *= z;
		return vec3(ndc2, z);
	}

	require modules::camera;

	out vec3 wsi_screen;

	const float near_plane = 0.1;
	const float far_plane = 1000.0;

	vec2 ndc_to_ss(vec2 p)
	{
		vec2 size = textureSize(fb.color, 0);
		return ((p / 2.0) + 0.5) * size;
	}

	vec3 project_point(vec3 point)
	{
		vec4 ph = camera.proj * vec4(point, 1.0);
		vec3 res = ph.xyz / ph.w;
		return vec3(ndc_to_ss(res.xy), res.z);
	}

	// origin is start of the ray, camera space
	// dir is the direction of the ray, camera space
	void project_ray(vec3 origin, vec3 dir, out vec3 ss_p0, out vec3 ss_p1)
	{
		if (dir.z == 0.0) {
			ss_p0 = project_point(origin);
			ss_p1 = project_point(origin + dir * 16000.0);	// max screen size is 16k because of that 'trick'
			return;
		}
		float len;
		if (dir.z > 0.0) {
			len = (far_plane - origin.z) / dir.z;
		} else {
			len = (near_plane - origin.z) / dir.z;
		}
		vec3 end = origin + dir * len;
		ss_p0 = project_point(origin);
		ss_p1 = project_point(end);
	}

	bool isShadow()
	{
		vec2 size = textureSize(fb.color, 0);
		vec3 sun_dir = normalize(vec3(1.0, 1.0, -1.0)).xyz;
		vec3 origin = current_view();
		vec3 p0, p1;
		project_ray(origin, sun_dir, p0, p1);
		vec2 dir = p1.xy - p0.xy;
		float dir_pp = 1.0 / length(dir);

		float z0 = p0.z;
		float z1 = p1.z;
		float t = 0.0;
		vec2 coord = p0.xy;
		bool base_comp = true;

		while (true) {
			t += dir_pp;
			coord = mix(p0.xy, p1.xy, t);

			if (!(coord.x > 0 && coord.y > 0 && coord.x <= (size.x - 1) && coord.y <= (size.y - 1) && t < 1.0))
				break;

			float depth = texture(fb.depth_buffer, coord / size * depth_buffer_uv).x;
			float ray_depth = mix(z0, z1, t);
			if ((depth > ray_depth) != base_comp)
				return true;
		}
		return false;
	}

	void main(void)
	{
		if (isShadow())
			(out)wsi_screen = texture(fb.color, gl_FragCoord.xy / textureSize(fb.color, 0)).xyz / 16.0;
		else
			(out)wsi_screen = texture(fb.color, gl_FragCoord.xy / textureSize(fb.color, 0)).xyz;
	}
}