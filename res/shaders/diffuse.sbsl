
require vertex::pnu;
vertex {
	require modules::camera;
}

fragment {
	set material {
		vec3 color;
		vec3 normal;
		uint counter;
	};
}

vertex {
	set object {
		float time;
		mat4 model_world;
	};

	/*set sub_object {
		uint lol;
		double xdd;
	};*/

	out vec3 vtx_pos;
	out vec3 vtx_normal;
	out vec2 vtx_uv;

	void main(void)
	{
		vec4 in_pos_h = vec4(in_vtx_pos, 1.0);
		gl_Position = camera.vp * object.model_world * in_pos_h;
		//gl_Position = vec4(in_pos.x, in_pos.y, 0, 1);
		vtx_pos = (object.model_world * in_pos_h).xyz;
		vtx_normal = (object.model_world * vec4(in_vtx_normal, 1.0)).xyz;
		vtx_uv = in_vtx_uv;
	}
}

//render_pass render_passes::deffered : albedo;

geometry {
	out vec3 geom_pos;
	out vec3 geom_normal;
	out vec2 geom_uv;

	const vec2 off[4] = {vec2(0), vec2(0.3), vec2(0.7), vec2(0.9)};

	void main(void)
	{
		for (int o = 0; o < off.length(); o++)
			for (int i = 0; i < 3; i++) {
				gl_Position = gl_in[i].gl_Position + vec4(off[o], 0, 0);
				geom_pos = vtx_pos[i];
				geom_normal = vtx_normal[i];
				geom_uv = vtx_uv[i];
				gl_Layer = -1;
				EmitVertex();
			}
		EndPrimitive();
	}
}

fragment {
	out vec3 screen_color;

	void main(void)
	{
		vec3 lightp = vec3(-2.0, 1.0, -3.0);
		float dist = length(lightp - geom_pos);

		vec3 color = normalize(geom_normal) + vec3(material.counter / 256.0);
		//vec3 color = vec3(1.0);
		screen_color = vec3(5.0 / (dist * dist)) * color;
	}
}

/*vertex {

	in vec3 in_pos;
	in vec3 in_normal;
	in vec2 in_uv;

	out vec3 vtx_pos;
	out vec3 vtx_normal;

	void main(void)
	{
		//vec3 in_pos = vec3(2.3);
		//vec2 pos;
		//gl_Position = object.mvp * vec4(in_pos, 1.0);
	}
}

fragment {
	out vec3 screen_color;

	void main(void)
	{
		screen_color = vec3(1.0);
	}
}*/