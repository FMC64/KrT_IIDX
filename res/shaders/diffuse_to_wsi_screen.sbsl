
render_pass render_passes::buffer_to_wsi_screen : compute;

require vertex::p2;
vertex {
	void main(void)
	{
		gl_Position = vec4((in)pos, 0, 1.0);
	}
}

fragment {
	set light {
		sampler2D diffuse;
		sampler2DArray cube_depth;
		float cam_a, cam_b;
	};

	float depth_to_z(float depth)
	{
		return light.cam_b / (depth - light.cam_a);
	}

	out vec3 wsi_screen;

	const float cube_size = 300.0;

	void main(void)
	{
		int layer = int(gl_FragCoord.x / cube_size);
		if (layer < 6 && gl_FragCoord.y < cube_size) {
			vec2 range = textureLod(light.cube_depth, vec3((gl_FragCoord.x - cube_size * layer) / cube_size, gl_FragCoord.y / cube_size, layer), 0).xy;
			(out)wsi_screen = vec3(depth_to_z(range.x) / 1000.0, depth_to_z(range.y) / 1000.0, 0.0);
		} else
			(out)wsi_screen = texture(light.diffuse, gl_FragCoord.xy).xyz * 0.8;
	}
}